#  集合

## HashMap的重要参数：
### capacity（容量）
容量默认值为16，最大值 2的30次方。默认情况下，当我们设置HashMap的初始化容量时，实际上HashMap会采用第一个大于该数值的2的幂作为初始化容量。也就是说，当我们通过`HashMap(int initialCapacity)`设置初始容量的时候，HashMap并不一定会直接采用我们传入的数值，而是经过计算，得到一个新值，目的是提高hash的效率。

jdk1.8中，在调用HashMap的构造函数定义HashMap的时候，就会进行容量的设定。而在Jdk 1.7中，要等到第一次put操作时才进行这一操作。在《阿里巴巴Java开发手册》有以下建议。
```HashMap 使用HashMap(int initialCapacity) 初始化。
正例：initialCapacity = (需要存储的元素个数/ 负载因子) + 1。注意负载因子（即loaderfactor）默认为0.75，如果暂时无法确定初始值大小，请设置为16（即默认值）。
```

在日常开发中，可以使用

```java
Map<String, String> map = Maps.newHashMapWithExpectedSize(10);
```

来创建一个HashMap，计算的过程guava会帮我们完成。

hashmap每次扩容都是以 2的整数次幂进行扩容，` int index =key.hashCode()&(length-1)`，只有数组长度为2的n次，2的n次-1的二进制表示才会刚好全为1，这样&运算才能分布均匀，减少碰撞。所以HashMap规定了其容量必须是2的n次方。由于HashMap规定了其容量是2的n次方，所以我们采用位运算<<来控制HashMap的大小。使用位运算同时还提高了Java的处理速度。
HashMap内部由Entry[]数组构成，Java的数组下标是由Int表示的。所以对于HashMap来说其最大的容量应该是不超过int最大值的一个2的指数幂，而最接近int最大值的2个指数幂用位运算符表示就是 1 << 30。

### size （个数）

 map中的键值对个数

### threshold （阀值）
表示当HashMap的size大于此值时就会执行扩容操作（`threshold=capacity*loadFactor`）
### load_factor （负载）
用来衡量HashMap满的程度，默认值0.75。

如果是0.5 ， 那么每次达到容量的一半就进行扩容，默认容量是16， 达到8就扩容成32，达到16就扩容成64， 最终使用空间和未使用空间的差值会逐渐增加，空间利用率低下。  如果是1，那意味着每次空间使用完毕才扩容，在一定程度上会会降低空间开销，但同时会增加put时候的时间（put过程中可能需要扩容）。默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。

### treeify_threshold（树形化阈值）
默认值 8，数组的元素上挂的链表长度大于该值时，将该链表转成红黑树。理想情况下，在随机哈希码和默认大小调整阈值为 0.75 的情况下,存储桶中元素个数出现的频率遵循泊松分布。由此可推算出，一个哈希桶达到 9 个元素的概率小于一千万分之一。红黑树相比链表占用了更多的引用，而且当元素个数过少时，红黑树的效率并不一定比链表好。
### untreeify_threshold（桶的链表还原阈值）
默认值为6，在扩容时，重新计算存储位置后，如果原有的红黑树内数量 < 6，则将 红黑树转换成链表。
### min_treeify_capacity（最小树形化容量阈值）
即 当哈希表中的容量 > 该值时，才允许树形化链表 （即 将链表 转换成红黑树）。
## ConcurrentHashMap
### jdk7 并发处理思路：
将map拆分成多个Segment(默认16个)。

Segment 字面翻译是一段，部分的意思，但我们更多称之为”槽”。操作`ConcurrentHashMap`细化到操作某一个Segment。Segment 继承 `ReentrantLock`类 。在多线程环境下，对`ConcurrentHashMap`并发操作时，只要锁住一个 segment，就可以保证这个 Segment 是线程安全的。其他线程操作可以同时操作其他的Segment，多个Segment之间互不影响，这便可实现并发操作，保证了全局的线程安全。这样以来，Segment就类似一个小型的hashMap，`ConcurrentHashMap`就是HashMap集合。
get方法不需要加锁，get为只读操作，不会改动map数据结构，所以在操作过程中，只需要保证涉及读取数据的属性为线程可见即可，也即使用volatile修饰。

### jdk8版本:
直接抛弃了Segment的设计，采用了较为轻捷的`Node + CAS + Synchronized`设计，保证线程安全。
即使用get方法获取时，使用cas，使用put方法时，使用 Synchronized 。

> 容器的复合操作： 复合操作包括迭代（反复获取元素，直到容器中的最后一个元素）、导航（根据一定顺序查找下一|元素）、条件运算（比如缺少即加入）。
>

### 总结：
多线程复合操作时，` ConcurrentHashMap` 使用锁分离(jdk7)/cas(jdk8)方式保证并发环境下，添加/删除操作安全，但这进针对的是单个put 或者 remove方法，如果多个方法配合复合使用，则并不能保证线程安全，此时依然需要额外加锁。
多线程同时添加相同hash 码值时转换成红黑树时，并不存在并发问题。`ConcurrentHashMap`链表转换成红黑树时，对转换方法做加锁防护了（使用synchronized ）。




# JUC


## cas
### 独占锁：
是一种悲观锁，`synchronized`就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。

### 乐观锁：
每次不加锁，假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止。
CAS 用的就是乐观锁机制。

### CAS(Compare And Swap)：
比较并交换，是CPU硬件级别提供的功能，`java.util.concurrent`包中使用该技术实现乐观锁，换句话说`java.util.concurrent`包是完全建立在`CAS`之上，`AQS同步组件`、`Atomic原子类操作`等都是基于CAS实现的。
CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。
java中具体的`CAS`操作是由类`sun.misc.Unsafe`来负责的。Unsafe类提供了硬件级别的原子操作（即native方法），Java使用native方法来间接访问操作系统底层（如系统硬件等)，扩展Java程序的功能。native具体方法使用C++实现。`sun.misc.Unsafe`提供了三个`CAS`操作，从方法名即可看出，分别针对Object类型、int类型和long类型。上文说过`CAS`有3个操作数，内存值V，旧的预期值A，要修改的新值B，但是仔细看Unsafe提供的`CAS`操作有4个操作数，这是因为`Unsafe`提供的`CAS`操作具体实现是使用C++来实现的，C++可以直接操作内存，有效提升操作效率，直接用对象和字段偏移量来获取内存值V，第一个参数是要修改field所在的对象 ，第二个参数是对象中需要修改的field的偏移量（field偏移量这个参数所代表的意思是某个字段相对Java对象的“起始地址”的偏移量，Unsafe提供了一个方法`objectFieldOffset(Field var1)`来获取这个参数值，对于field偏移量的理解可以参考这里），第三个参数就是旧的预期值A，第四个参数是要修改的新值B。

### CAS缺陷：
- 循环时间长导致CPU负载高
`CAS`操作一般和循环搭配使用（即我们所说的`自旋CAS`），直到修改成功才会退出循环。在某些并发量较大的情况下，变量的值始终被别的线程修改，`自旋CAS`长时间地不成功，则会给CPU带来非常大的开销。但 在并发量不是很高的情况下，`CAS`的效率远远高于锁机制。还有一种策略就是限制`CAS`自旋的次数。
- 只能保证一个共享变量原子操作
`CAS`只能针对一个共享变量，如果是多个共享变量有三种方案，一是使用锁；二是把多个变量合并为一个变量，比如juc包中的`Phaser`类中的`status`字段可以表示四个变量；三是把多个变量放在一个对象里来使用`AtomicReference`类进行`CAS`操作改变引用地址以达到修改变量的目的。
- 可能导致ABA问题
## ABA问题
线程1准备用`CAS`将变量的值由A替换为C，在此之前，线程2将变量的值由A替换为B，又由B替换为A，然后线程1执行`CAS`时发现变量的值仍然为A，所以`CAS`成功。但实际上这时的现场已经和最初不同了，尽管`CAS`成功，但可能存在潜藏的问题。

有个用单链表实现的栈 ,A --> B --> C

## AQS

`AQS` 指的是 `AbstractQueuedSynchronizer `类，这是一个抽象类，翻译成中文就是**抽象队列同步器**。它提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，`ReentrantLock`、`Semaphore`、`CountDownLatch`、`CyclicBarrier`等并发类均是基于`AQS`来实现的，具体用法是通过继承`AQS`实现其模板方法，然后将子类作为同步组件的内部类。

###  state状态

`AQS`维护了一个`volatile`语义的共享资源变量state，用来表示当前同步状态。volatile虽然不能保证操作的原子性，但是保证了当前变量state的可见性。

资源的共享方式分为2种：
- 在一些线程协调的场景中，一个线程在进行某些操作的时候其他的线程都不能执行该操作，比如持有锁时的操作，在同一时刻只能有一个线程持有锁，我们把这种情景称为独占模式，如`ReentrantLock`；
- 在另一些线程协调的场景中，可以同时允许多个线程同时进行某种操作，我们把这种情景称为共享模式，如`CountDownLatch`。

我们可以通过修改state字段代表的同步状态来实现多线程的独占模式或者共享模式。
在独占模式下，我们可以把state的初始值设置成0，每当某个线程要进行某项独占操作前，都需要判断state的值是不是0，如果不是0的话意味着别的线程已经进入该操作，则本线程需要阻塞等待；如果是0的话就把state的值设置成1，自己进入该操作。这个先判断再设置的过程我们可以通过CAS操作保证原子性，我们把这个过程称为尝试获取同步状态。如果一个线程获取同步状态成功了，那么在另一个线程尝试获取同步状态的时候发现state的值已经是1了就一直阻塞等待，直到获取同步状态成功的线程执行完了需要同步的操作后释放同步状态，也就是把state的值设置为0，并通知后续等待的线程。

在共享模式下的道理也差不多，比如说某项操作我们允许10个线程同时进行，超过这个数量的线程就需要阻塞等待。那么我们就可以把state的初始值设置为10，一个线程尝试获取同步状态的意思就是先判断state的值是否大于0，如果不大于0的话意味着当前已经有10个线程在同时执行该操作，本线程需要阻塞等待；如果state的值大于0，那么可以把state的值减1后进入该操作，每当一个线程完成操作的时候需要释放同步状态，也就是把state的值加1，并通知后续等待的线程。

### CLH队列(FIFO)

`AQS`中还维护了一个所谓的`同步队列`。每一个节点都代表一个线程。当一个线程获取同步状态失败之后，就把这个线程阻塞并包装成Node节点插入到这个同步队列中，当获取同步状态成功的线程释放同步状态的时候，同时通知在队列中下一个未获取到同步状态的节点，让该节点的线程再次去获取同步状态。
AQS中定义一个头节点引用，一个尾节点引用。通过这两个节点就可以控制到这个队列。



AQS 类使用模板方法模式，定义了获取锁，释放锁等方法，部分实现了操作锁时对 state和 同步队列的操作。当我们需要自定义自己的同步工具的时候，就定义这个类的子类并覆盖它提供的一些方法。

## unsafe

Java和C++语言的一个重要区别就是Java中我们无法直接操作一块内存区域，不能像C++中那样可以自己申请内存和释放内存。Java中的Unsafe类为我们提供了类似C++手动管理内存的能力。

Unsafe类是"final"的，不允许继承。且构造函数是private的。在使用这个类的时候，需要通过反射创建实例。

unsafe类有 读写普通变量，读写volatile变量，有序写入，直接内存操作（分配内存，重新分配内存，内存初始化，内存复制，清除内存），CAS操作 int long和Object 变量，线程调度，类加载，内存屏障等功能。

## volatile

###  JMM （Java memory model)

Java的多线程之间是通过共享内存进行通信的。

Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。

不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

###  volatile 的特性

- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（实现可见性）

- 禁止进行指令重排序。（实现有序性）

- volatile 只能保证对单次读/写的原子性。i++ 这种操作不能保证原子性。

## sync
## 常见的各种lock
## 死锁
## 线程池参数和如何合理的去设置
## 自旋
## 阻塞
## 死锁和它如何去定位
## oom如何定位问题
## cpu过高如何定位
## top
## jps
## jstack
## jmap
## jmm模型
## mesi协议

























